#!/usr/bin/env bash
# Install dependencies and build Emacs

set -euo pipefail
IFS=$'\n\t'

print_help() {
	cat <<EOF
setup - Set up the Emacs environment by installing dependencies, downloading
        source, building, and installing.

usage: setup TARGET [ TASK ]

  Where TARGET is one of:

    emacs

    mu4e

  And TASK is one of:

    deps     Install and update OS dependencies

    fetch    Fetch the Emacs source repository
             ARGS: [ BUILD_DIRECTORY ] [ REPOSITORY_URL ]

    build    Build Emacs and modules
             ARGS: [ BUILD_DIRECTORY ]

    install  Install Emacs on the local machine
             ARGS: [ BUILD_DIRECTORY ]

    all      Run all four. This is the default if no task is specified.


EOF
}

base="${EMACS_SETUP_BASE:-$HOME/.emacs.d/src}"

required=(
	autoconf
	cmake
	texinfo
	libxml2
	imagemagick
	librsvg
	gnutls
	gnupg
	jansson
	cairo
	libvterm
)

required_mu4e=(
	automake
	libgpg-error
	libtool
	pkg-config
	gettext
	glib
	gmime
	xapian
	guile
	isync
)

required_casks=(mactex)

configure_opts=(
	CFLAGS='-Ofast -march=native -pipe -falign-functions=64 -fomit-frame-pointer -funit-at-a-time -fforce-addr -mfpmath=sse -ffast-math -fno-finite-math-only -fstack-check -I/usr/local/opt/libxml2/include/libxml2'
	PKG_CONFIG_PATH="PKG_CONFIG_PATH:/usr/local/opt/gnutls/lib/pkgconfig:/usr/local/opt/nettle/lib/pkgconfig:/usr/local/opt/libtasn1/lib/pkgconfig:/usr/local/opt/p11-kit/lib/pkgconfig"
)

# The ctags bit is to rename the ctags binary so it doesn't conflict with an
# existing, non-emacs ctags installation
emacs_configure_opts=(
	--config-cache
	--without-pop
	--with-ns
	--disable-ns-self-contained
	--with-cairo
	--with-imagemagick
	--with-modules
	--program-transform-name='s/^ctags$/ctags.emacs/'
	"${configure_opts[@]}"
)

# Print the given arguments out in a nice heading
heading() {
	printf "\n\033[38;5;013m * %s  \033[0m  \n\n" "$*"
}

# Return exit code 0 if $1 is the same as any of the rest of the arguments
contains() {
	local e match="$1"
	shift
	for e in "$@"; do [ "$e" = "$match" ] && return 0; done
	return 1
}

# Ensure the directory to which we will install Emacs exists and has the correct
# permissions set.
ensure_install_directory() {
	local libexec=/usr/local/libexec/emacs
	if [ ! -d $libexec ]; then
		sudo mkdir -p $libexec
		chown $USER $libexec
	fi
}

# Ensure the given homebrew packages are installed and up to date
# brew_ensure [ cask ] dep1 [ dep2 ] [ ... ]
brew_ensure() {
	local prefix required missing outdated upgrade
	# Decide if we are operating on 'brew' or 'brew cask'
	prefix="brew "
	[ "$1" = "cask" ] && prefix="${prefix}cask " && shift

	# Get list of missing packages, install them
	installed=($(eval $prefix list -1))
	required=("$@")
	for p in "${required[@]}"; do
		contains "$p" "${installed[@]}" || missing+=("$p")
	done
	if [ -n "${missing[*]:-}" ]; then
		echo "Installing packages: ${missing[*]}"
		eval $prefix install "${missing[@]}"
	fi

	# Get list of outdated packages, upgrade them
	outdated="$(eval $prefix outdated | awk '{print $1}')"
	upgrade=()
	for p in "${required[@]}"; do
		contains "$p" "${outdated[@]}" && upgrade+=("$p")
	done
	if [ -n "${upgrade[*]:-}" ]; then
		echo "Upgrading packages: ${upgrade[*]}"
		eval $prefix upgrade "${upgrade[@]}"
	fi
}

# Print the number of CPU cores on the local machine
how_many_cores() {
	case "$(uname)" in
	Darwin)
		sysctl -n hw.ncpu
		;;
	Linux)
		awk '/^processor/ {++n} END {print n}' /proc/cpuinfo
		;;
	esac
}

# Install Emacs dependencies
deps_emacs() {
	heading "Installing Dependencies for Emacs..."

	brew_ensure "${required[@]}"
	brew_ensure cask "${required_casks[@]}"
	brew install --HEAD universal-ctags/universal-ctags/universal-ctags

	# Apparently gnutls is bottled now.
	which gnutls || PATH="$(brew --prefix gnutls):$PATH"
}

# Install Emacs dependencies
deps_mu4e() {
	heading "Installing Dependencies for mu4e..."

	brew_ensure "${required_mu4e[@]}"
}

deps() {
	local target="$1"
	case "$target" in
	emacs) deps_emacs ;;
	mu4e) deps_mu4e ;;
	esac
}

# Fetch the Emacs source repository
fetch() {
	local repo="$1"
	local target="$2"
	heading "Fetching source for $target..."
	echo "Source directory will be $base/$target"

	mkdir -p "$base"
	pushd "$base"

	[ -d "$base/$target" ] || git clone "$repo" "$target"
	pushd "$base/$target"

	git pull
}

# Build Emacs from source
build_it() {
	local target="$1"
	shift
	heading "Building $target..."

	pushd "$base/$target"

	./autogen.sh
	./configure "$@"
	make -j $make_jobs

	popd
}

build() {
	local target="$1"
	case "$target" in
	emacs) build_it "$target" "${emacs_configure_opts[@]}" ;;
	mu4e) build_it "$target" "${configure_opts[@]}" ;;
	esac
}

# Install Emacs from the build directory
install_emacs() {
	heading "Installing Emacs..."

	ensure_install_directory

	pushd "$base/$target"

	# Even though we move the binary ourselves, we still need to install to get the
	# Emacs Lisp and C source files in the right place.
	make -j $make_jobs install
	rm -rf "$HOME/Applications/Emacs.app"
	mv nextstep/Emacs.app "$HOME/Applications/"

	popd
}

install_mu4e() {
	heading "Installing Emacs..."

	pushd "$base/$target"

	make -j $make_jobs install
}

install() {
	local target="$1"
	case "$target" in
	emacs) install_emacs "$target" ;;
	mu4e) install_mu4e "$target" ;;
	esac
}

make_jobs=$((2 * $(how_many_cores)))

target="${1:-emacs}"
task="${2:-all}"

case "$target" in
emacs)
	repo="${2:-https://git.savannah.gnu.org/git/emacs.git}"
	;;
mu4e)
	repo="${2:-https://github.com/djcb/mu.git}"
	;;
esac

case "$task" in
deps)
	deps
	;;
fetch)
	fetch "$repo" "$target"
	;;
build)
	build "$target"
	;;
mu4e)
	fetch
	;;
-h | --help | h*) print_help ;;
all)
	deps "$target"
	fetch "$repo" "$target"
	build "$target"
	install "$target"
	;;
esac
